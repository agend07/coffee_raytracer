// Generated by CoffeeScript 1.6.2
(function() {
  var Canvas, CheckerboardSurface, EPSILON, Halfspace, Point, Ray, RayTracer, Scene, SimpleSurface, Sphere, Vector, addColours, firstIntersection, _ref,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  Canvas = (function() {
    Canvas.prototype.width = 64 * 10;

    Canvas.prototype.height = 48 * 10;

    function Canvas(options) {
      var key, value;

      if (options == null) {
        options = {};
      }
      for (key in options) {
        value = options[key];
        this[key] = value;
      }
      this.createCanvas();
    }

    Canvas.prototype.createCanvas = function() {
      var canvas;

      canvas = document.createElement('canvas');
      canvas.width = this.width;
      canvas.height = this.height;
      document.body.appendChild(canvas);
      this.ctx = canvas.getContext('2d');
      return this.canvasData = this.ctx.getImageData(0, 0, this.width, this.height);
    };

    Canvas.prototype.putInRange = function(value) {
      value = value * 255;
      if (value < 0) {
        value = 0;
      }
      if (value > 255) {
        value = 255;
      }
      return value;
    };

    Canvas.prototype.plot = function(x, y, colour) {
      var b, g, index, r;

      if (colour == null) {
        colour = [0, 0, 0];
      }
      y = this.height - y;
      r = colour[0], g = colour[1], b = colour[2];
      index = (x + y * this.width) * 4;
      this.canvasData.data[index + 0] = this.putInRange(r);
      this.canvasData.data[index + 1] = this.putInRange(g);
      this.canvasData.data[index + 2] = this.putInRange(b);
      return this.canvasData.data[index + 3] = 255;
    };

    Canvas.prototype.updateCanvas = function() {
      return this.ctx.putImageData(this.canvasData, 0, 0);
    };

    Canvas.prototype.paintBackground = function(color) {
      if (color == null) {
        color = "#ffeeaa";
      }
      this.ctx.fillStyle = color;
      return this.ctx.fillRect(0, 0, this.width, this.height);
    };

    return Canvas;

  })();

  Point = (function() {
    function Point(x, y, z) {
      this.x = x != null ? x : 0;
      this.y = y != null ? y : 0;
      this.z = z != null ? z : 0;
    }

    Point.prototype.add = function(other) {
      if (other.getType() !== 'Vector') {
        throw 'other must be a Vector';
      }
      return new Point(this.x + other.x, this.y + other.y, this.z + other.z);
    };

    Point.prototype.substract = function(other) {
      if (other.getType() === 'Point') {
        return new Vector(this.x - other.x, this.y - other.y, this.z - other.z);
      } else {
        return new Point(this.x - other.x, this.y - other.y, this.z - other.z);
      }
    };

    Point.prototype.getType = function() {
      return 'Point';
    };

    return Point;

  })();

  Vector = (function(_super) {
    __extends(Vector, _super);

    function Vector() {
      _ref = Vector.__super__.constructor.apply(this, arguments);
      return _ref;
    }

    Vector.prototype.add = function(other) {
      return new Vector(this.x + other.x, this.y + other.y, this.z + other.z);
    };

    Vector.prototype.substract = function(other) {
      return new Vector(this.x - other.x, this.y - other.y, this.z - other.z);
    };

    Vector.prototype.magnitude = function() {
      return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
    };

    Vector.prototype.scale = function(n) {
      return new Vector(this.x * n, this.y * n, this.z * n);
    };

    Vector.prototype.dot = function(other) {
      return this.x * other.x + this.y * other.y + this.z * other.z;
    };

    Vector.prototype.cross = function(other) {
      return new Vector(this.y * other.z - this.z * other.y, this.z * other.x - this.x * other.z, this.x * other.y - this.y * other.x);
    };

    Vector.prototype.normalized = function() {
      return this.scale(1 / this.magnitude());
    };

    Vector.prototype.negated = function() {
      return this.scale(-1);
    };

    Vector.prototype.reflectThrough = function(normal) {
      var d;

      d = normal.scale(this.dot(normal));
      return this.substract(d.scale(2));
    };

    Vector.prototype.getType = function() {
      return 'Vector';
    };

    return Vector;

  })(Point);

  EPSILON = 0.00001;

  Vector.ZERO = new Vector(0, 0, 0);

  Vector.RIGHT = new Vector(1, 0, 0);

  Vector.UP = new Vector(0, 1, 0);

  Vector.OUT = new Vector(0, 0, 1);

  Point.ZERO = new Point(0, 0, 0);

  addColours = function(a, scale, b) {
    return [a[0] + scale * b[0], a[1] + scale * b[1], a[2] + scale * b[2]];
  };

  firstIntersection = function(intersections) {
    var candidateT, i, result, _i, _len;

    result = null;
    for (_i = 0, _len = intersections.length; _i < _len; _i++) {
      i = intersections[_i];
      candidateT = i[1];
      if (candidateT && candidateT > -EPSILON) {
        if (!result || candidateT < result[1]) {
          result = i;
        }
      }
    }
    return result;
  };

  Ray = (function() {
    function Ray(point, vector) {
      this.point = point;
      this.vector = vector.normalized();
    }

    Ray.prototype.pointAtTime = function(t) {
      return this.point.add(this.vector.scale(t));
    };

    return Ray;

  })();

  Sphere = (function() {
    function Sphere(centre, radius) {
      this.centre = centre;
      this.radius = radius;
      if (this.centre.getType() !== 'Point') {
        throw 'centre must be a point';
      }
    }

    Sphere.prototype.intersectionTime = function(ray) {
      var cp, discriminant, v;

      cp = this.centre.substract(ray.point);
      v = cp.dot(ray.vector);
      discriminant = (this.radius * this.radius) - (cp.dot(cp) - v * v);
      if (discriminant < 0) {
        return null;
      } else {
        return v - Math.sqrt(discriminant);
      }
    };

    Sphere.prototype.normalAt = function(p) {
      return (p.substract(this.centre)).normalized();
    };

    return Sphere;

  })();

  Halfspace = (function() {
    function Halfspace(point, normal) {
      this.point = point;
      this.normal = normal.normalized();
    }

    Halfspace.prototype.intersectionTime = function(ray) {
      var v;

      v = ray.vector.dot(this.normal);
      if (v) {
        return 1 / -v;
      } else {
        return null;
      }
    };

    Halfspace.prototype.normalAt = function(p) {
      return this.normal;
    };

    return Halfspace;

  })();

  SimpleSurface = (function() {
    function SimpleSurface(baseColour, specular, lambert, ambient) {
      this.baseColour = baseColour != null ? baseColour : [1, 1, 1];
      this.specular = specular != null ? specular : 0.2;
      this.lambert = lambert != null ? lambert : 0.6;
      this.ambient = ambient != null ? ambient : 1 - this.specular - this.lambert;
    }

    SimpleSurface.prototype.baseColourAt = function(p) {
      return this.baseColour;
    };

    SimpleSurface.prototype.colourAt = function(scene, ray, p, normal) {
      var b, c, contribution, lambertAmount, lightPoint, reflectedColour, reflectedRay, _i, _len, _ref1;

      b = this.baseColourAt(p);
      c = [0, 0, 0];
      if (this.specular > 0) {
        reflectedRay = new Ray(p, ray.vector.reflectThrough(normal));
        reflectedColour = scene.rayColour(reflectedRay);
        c = addColours(c, this.specular, reflectedColour);
      }
      if (this.lambert > 0) {
        lambertAmount = 0;
        _ref1 = scene.visibleLights(p);
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          lightPoint = _ref1[_i];
          contribution = (lightPoint.substract(p)).normalized().dot(normal);
          if (contribution > 0) {
            lambertAmount = lambertAmount + contribution;
          }
          lambertAmount = Math.min.apply(null, [1, lambertAmount]);
          c = addColours(c, this.lambert * lambertAmount, b);
        }
      }
      if (this.ambient > 0) {
        c = addColours(c, this.ambient, b);
      }
      return c;
    };

    return SimpleSurface;

  })();

  CheckerboardSurface = (function(_super) {
    __extends(CheckerboardSurface, _super);

    function CheckerboardSurface(baseColour, specular, lambert, ambient) {
      this.baseColour = baseColour != null ? baseColour : [1, 1, 1];
      this.specular = specular != null ? specular : 0.2;
      this.lambert = lambert != null ? lambert : 0.6;
      this.ambient = ambient != null ? ambient : 1 - this.specular - this.lambert;
      this.otherColour = [0, 0, 0];
      this.checkSize = 1;
    }

    CheckerboardSurface.prototype.baseColourAt = function(p) {
      var temp, v;

      v = p.substract(Point.ZERO);
      v = v.scale(1 / this.checkSize);
      temp = Math.round(Math.abs(v.x)) + Math.round(Math.abs(v.y)) + Math.round(Math.abs(v.z));
      if (temp % 2) {
        return this.baseColour;
      } else {
        return this.otherColour;
      }
    };

    return CheckerboardSurface;

  })(SimpleSurface);

  Scene = (function() {
    function Scene() {
      this.objects = [];
      this.lightPoints = [];
      this.position = new Point(0, 1.8, 10);
      this.lookingAt = Point.ZERO;
      this.fieldOfView = 45;
      this.recursionDepth = 0;
    }

    Scene.prototype.moveTo = function(point) {
      return this.position = point;
    };

    Scene.prototype.lookAt = function(point) {
      return this.lookingAt = point;
    };

    Scene.prototype.addObject = function(object, surface) {
      return this.objects.push([object, surface]);
    };

    Scene.prototype.addLight = function(point) {
      return this.lightPoints.push(point);
    };

    Scene.prototype.render = function(canvas) {
      var colour, currentfraction, eye, fovRadians, halfHeight, halfWidth, height, pixelHeight, pixelWidth, previousfraction, ray, vpRight, vpUp, width, x, xcomp, y, ycomp, _i, _j, _ref1, _ref2;

      console.log('Computing field of view');
      fovRadians = Math.PI * (this.fieldOfView / 2) / 180;
      halfWidth = Math.tan(fovRadians);
      halfHeight = 0.75 * halfWidth;
      width = halfWidth * 2;
      height = halfHeight * 2;
      pixelWidth = width / (canvas.width - 1);
      pixelHeight = height / (canvas.height - 1);
      eye = new Ray(this.position, this.lookingAt.substract(this.position));
      vpRight = eye.vector.cross(Vector.UP).normalized();
      vpUp = vpRight.cross(eye.vector).normalized();
      console.log('Looping over pixels');
      previousfraction = 0;
      for (y = _i = 0, _ref1 = canvas.height; 0 <= _ref1 ? _i < _ref1 : _i > _ref1; y = 0 <= _ref1 ? ++_i : --_i) {
        currentfraction = y / canvas.height;
        if (currentfraction - previousfraction > 0.05) {
          console.log("" + (Math.round(currentfraction * 100)) + " complete");
          previousfraction = currentfraction;
        }
        for (x = _j = 0, _ref2 = canvas.width; 0 <= _ref2 ? _j < _ref2 : _j > _ref2; x = 0 <= _ref2 ? ++_j : --_j) {
          xcomp = vpRight.scale(x * pixelWidth - halfWidth);
          ycomp = vpUp.scale(y * pixelHeight - halfHeight);
          ray = new Ray(eye.point, eye.vector.add(xcomp).add(ycomp));
          colour = this.rayColour(ray);
          canvas.plot(x, y, colour);
        }
      }
      canvas.updateCanvas();
      return console.log('completed');
    };

    Scene.prototype.rayColour = function(ray) {
      var i, intersections, object, p, result, surface, time;

      if (this.recursionDepth > 3) {
        return [0, 0, 0];
      }
      this.recursionDepth++;
      intersections = (function() {
        var _i, _len, _ref1, _ref2, _results;

        _ref1 = this.objects;
        _results = [];
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          _ref2 = _ref1[_i], object = _ref2[0], surface = _ref2[1];
          _results.push([object, object.intersectionTime(ray), surface]);
        }
        return _results;
      }).call(this);
      i = firstIntersection(intersections);
      if (!i) {
        this.recursionDepth--;
        return [0, 0, 0];
      } else {
        object = i[0], time = i[1], surface = i[2];
        p = ray.pointAtTime(time);
        result = surface.colourAt(this, ray, p, object.normalAt(p));
        this.recursionDepth--;
        return result;
      }
    };

    Scene.prototype.lightIsVisible = function(l, p) {
      var object, surface, t, _i, _len, _ref1, _ref2, _results;

      _ref1 = this.objects;
      _results = [];
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        _ref2 = _ref1[_i], object = _ref2[0], surface = _ref2[1];
        t = object.intersectionTime(new Ray(p, l.substract(p)));
        if (t && t > EPSILON) {
          _results.push(false);
        } else {
          _results.push(true);
        }
      }
      return _results;
    };

    Scene.prototype.visibleLights = function(p) {
      var l, result, _i, _len, _ref1;

      result = [];
      _ref1 = this.lightPoints;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        l = _ref1[_i];
        if (this.lightIsVisible(l, p)) {
          result.push(l);
        }
      }
      return result;
    };

    return Scene;

  })();

  RayTracer = (function() {
    function RayTracer() {
      var centre, end, radius, sphere, start, surface, y, _i;

      this.canvas = new Canvas;
      this.scene = new Scene;
      this.scene.addLight(new Point(30, 30, 10));
      this.scene.addLight(new Point(-10, 100, 30));
      this.scene.lookAt(new Point(0, 3, 0));
      this.scene.addObject(new Sphere(new Point(1, 3, -10), 2), new SimpleSurface([1, 1, 0]));
      for (y = _i = 0; _i <= 5; y = ++_i) {
        centre = new Point(-2 + y * 1, 4.3, -5 + y);
        surface = new SimpleSurface([y / 3, 1 - y / 3, y / 3]);
        radius = 0.4;
        sphere = new Sphere(centre, radius);
        this.scene.addObject(sphere, surface);
      }
      this.scene.addObject(new Halfspace(new Point(0, 0, 0), Vector.UP), new CheckerboardSurface());
      start = new Date;
      this.scene.render(this.canvas);
      end = new Date;
      console.log('time:', end - start);
    }

    return RayTracer;

  })();

  window.Point = Point;

  window.Vector = Vector;

  window.Ray = Ray;

  window.Sphere = Sphere;

  window.Halfspace = Halfspace;

  window.SimpleSurface = SimpleSurface;

  window.RayTracer = RayTracer;

  window.raytracer = function() {
    return new RayTracer;
  };

}).call(this);

/*
//@ sourceMappingURL=ray.map
*/
