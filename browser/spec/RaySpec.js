// Generated by CoffeeScript 1.6.2
(function() {
  describe("Point", function() {
    var point1, point2;

    point1 = null;
    point2 = null;
    beforeEach(function() {
      point1 = new Point(1, 0, 0);
      return point2 = new Point(0, 1, 0);
    });
    it("new point should be 1, 0, 0", function() {
      return expect(point1).toEqual(new Point(1, 0, 0));
    });
    it("should add vector to point", function() {
      var result, v;

      v = new Vector(0, 1, 0);
      result = point1.add(v);
      return expect(result).toEqual(new Point(1, 1, 0));
    });
    it("should not add 2 points, and throw exception", function() {
      return expect(function() {
        return point1.add(point2);
      }).toThrow();
    });
    it("should substract 2 points and return vector", function() {
      var result;

      result = point1.substract(point2);
      return expect(result).toEqual(new Vector(1, -1, 0));
    });
    return it("should substract vector from point and and return point", function() {
      var result, v;

      v = new Vector(0, 1, 0);
      result = point1.substract(v);
      return expect(result).toEqual(new Point(1, -1, 0));
    });
  });

  describe("Vector", function() {
    var vector1, vector2, vector3;

    vector1 = null;
    vector2 = null;
    vector3 = null;
    beforeEach(function() {
      vector1 = new Vector(1, 0, 0);
      vector2 = new Vector(3, 0, 1);
      return vector3 = new Vector(1, 2, 3);
    });
    it("new vector should be 1, 0, 0", function() {
      return expect(vector1).toEqual(new Vector(1, 0, 0));
    });
    it("vector should have magniutude of 1", function() {
      expect(vector1.magnitude()).toEqual(1);
      return expect(vector2.magnitude()).toBeCloseTo(3.162277, 5);
    });
    it("should scale the vector", function() {
      var result;

      result = vector1.scale(2);
      expect(result.magnitude()).toEqual(2);
      return expect(result).toEqual(new Vector(2, 0, 0));
    });
    it("should give the dot product", function() {
      expect(vector1.dot(vector2)).toEqual(3);
      return expect(vector2.dot(vector1)).toEqual(3);
    });
    it("should give the cross product", function() {
      var result;

      result = vector1.cross(vector2);
      expect(result).toEqual(new Vector(0, -1, 0));
      result = vector2.cross(vector1);
      return expect(result).toEqual(new Vector(0, 1, 0));
    });
    it("should normalize vector", function() {
      var result;

      result = vector1.scale(3);
      expect(result.magnitude()).toEqual(3);
      result = result.normalized();
      return expect(result.magnitude()).toEqual(1);
    });
    it("should nagate vector", function() {
      var result;

      result = vector3.negated();
      return expect(result).toEqual(new Vector(-1, -2, -3));
    });
    it("should reflect through", function() {
      var result, v1, v2;

      v1 = new Vector(1, 2, 3);
      v2 = new Vector(4, 5, 6);
      result = v1.reflectThrough(v2);
      expect(result).toEqual(new Vector(-255, -318, -381));
      v1 = new Vector(-1, -2, -3);
      v2 = new Vector(4, 5, 6);
      result = v1.reflectThrough(v2);
      expect(result).toEqual(new Vector(255, 318, 381));
      v1 = new Vector(1, 1, 1);
      v2 = new Vector(4, 5, 6);
      result = v1.reflectThrough(v2);
      return expect(result).toEqual(new Vector(-119, -149, -179));
    });
    it("should reflectThrough Vector.RIGHT", function() {
      var result;

      result = Vector.RIGHT.reflectThrough(Vector.UP);
      return expect(result).toEqual(Vector.RIGHT);
    });
    return it("should reflectThrough Vector -1, -1, 0", function() {
      var result, v;

      v = new Vector(-1, -1, 0);
      result = v.reflectThrough(Vector.UP);
      return expect(result).toEqual(new Vector(-1, 1, 0));
    });
  });

  describe("Ray", function() {
    var point, ray, vector;

    point = null;
    vector = null;
    ray = null;
    beforeEach(function() {
      point = new Point(1, 1, 1);
      vector = new Vector(1, 2, 3);
      return ray = new Ray(point, vector);
    });
    it("should normalize the vector", function() {
      return expect(ray.vector.magnitude()).toEqual(1);
    });
    return it("should calculate pointAtTime", function() {
      var result;

      result = ray.pointAtTime(10);
      return expect(result).toEqual(new Point(3.6726124191242437, 6.3452248382484875, 9.017837257372731));
    });
  });

  describe("Sphere", function() {
    var point;

    point = null;
    beforeEach(function() {
      return point = new Point(1, 1, 1);
    });
    it("should create the sphere", function() {
      var sphere;

      sphere = new Sphere(point, 10);
      expect(sphere.centre).toEqual(new Point(1, 1, 1));
      return expect(sphere.radius).toEqual(10);
    });
    it("should calculate intersectionTime", function() {
      var ray, result, sphere;

      sphere = new Sphere(point, 10);
      ray = new Ray(new Point(1, 2, 3), new Vector(2, 3, 4));
      result = sphere.intersectionTime(ray);
      return expect(result).toEqual(-12.001183441135396);
    });
    return it("should calculate normalAt", function() {
      var point2, result, sphere;

      sphere = new Sphere(point, 10);
      point2 = new Point(3, 4, 5);
      result = sphere.normalAt(point2);
      return expect(result).toEqual(new Vector(0.3713906763541037, 0.5570860145311556, 0.7427813527082074));
    });
  });

  describe("Halfspace", function() {
    it("should normalize the normal vector", function() {
      var halfspace;

      halfspace = new Halfspace(new Point(1, 1, 1), new Vector(5, 5, 5));
      return expect(halfspace.normal.magnitude()).toEqual(1);
    });
    return it("should calculate intersectionTime", function() {
      var halfspace, ray, result;

      halfspace = new Halfspace(new Point(1, 1, 1), new Vector(5, 5, 5));
      ray = new Ray(new Point(1, 2, 3), new Vector(2, 3, 4));
      result = halfspace.intersectionTime(ray);
      return expect(result).toEqual(-1.0363754503432019);
    });
  });

}).call(this);

/*
//@ sourceMappingURL=RaySpec.map
*/
